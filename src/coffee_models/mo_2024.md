# Code-to-Paper Mapping: Coffee Extraction Simulation

## Overview: Multi-Scale Model Architecture

The paper describes a **1D coarse-grained model** that couples **particle-level physics** with **bed-level transport**. The code implements this through a hierarchical structure:

```
CoffeeExtraction (bed-level) 
    ├── SwellingParticle[] (particle-level fines)
    └── SwellingParticle[] (particle-level coarses)
```

---

## 1. **Particle-Level Swelling Model** 
**Paper Section 2.1** → **Code: `SwellingParticle.step_swelling()`**

### Mathematical Foundation (Paper Eq. 3):
```
∂c_w/∂t = D_w(1 - c_w)∇²c_w
```

### Code Implementation:
```python
def step_swelling(self, dt: float):
    # Build coefficient matrix for Crank-Nicolson
    A = self._build_swelling_matrix(dt)
    
    # Boundary conditions from paper Eq. 6 & 45
    A[0, 0] = 1.0   # Center: ∂c_w/∂R = 0
    A[-1, -1] = 1.0 # Surface: c_w = C_M
    rhs[-1] = self.params.C_M
    
    # Solve and update geometry via paper Eq. 1
    c_w_new = spsolve(A, rhs)
    self.update_geometry()  # r³ = R₀³ + 3∫[ξ²/(1-c_w)]dξ
```

**Key Paper Connections:**
- **Eq. 1**: Deformation gradient `F = [1-c_w]^(-1/d_n) I` → `update_geometry()`
- **Eq. 8**: Maximum swelling `s_m = [(1-C_M)^(-1/d_n) - 1] × 100%`
- **Appendix A.1**: Spherical coordinate transformation → `_build_swelling_matrix()`

---

## 2. **Particle-Level Extraction Model**
**Paper Section 2.2** → **Code: `SwellingParticle.step_extraction()`**

### Mathematical Foundation (Paper Eq. 9):
```
∂c/∂t = ∇·(D_p∇c) - c·D_w·∇²c_w
```

### Code Implementation:
```python
def step_extraction(self, dt: float):
    # Effective diffusion from paper Eq. 10-11
    eps_p_eff = 1 - (1 - self.params.eps_p) * (1 - self.c_w)
    D_p = self.params.D_b * eps_p_eff / (self.params.beta * self.params.H_c)
    
    # Source term from swelling (paper Eq. 9, second term)
    laplacian_cw = self._compute_laplacian(self.c_w)
    source = -self.c * self.params.D_w * laplacian_cw
    
    # Boundary condition from paper Eq. 16
    if c_surface_target < self.c[-2]:  # Extraction occurs
        A[-1, -1] = 1.0
        rhs[-1] = self.c_b_boundary / self.params.K  # Partition coefficient
```

**Key Paper Connections:**
- **Eq. 10**: Diffusion coefficient `D_p = D_b·ε_p/(β·H_c)` 
- **Eq. 11**: Porosity evolution `ε_p = 1 - (1-ε_p⁰)(1-c_w)`
- **Eq. 16**: Boundary condition with partition coefficient K
- **Eq. 17**: Flux calculation `j = -D_p(∂c/∂r)(dr/dR)` → `get_flux()`

---

## 3. **Bed-Level Transport Model**
**Paper Section 2.3** → **Code: `CoffeeExtraction._step_bed_transport()`**

### Mathematical Foundation (Paper Eq. 20):
```
∂c_b/∂t = -v·∂c_b/∂z + (1/ε_b)·Source_particles - (∂ε_b/∂t)·c_b/ε_b
```

### Code Implementation:
```python
def _step_bed_transport(self, dt: float):
    # Source from particles (paper Eq. 20, second term)
    for i in range(self.N):
        j_f = self.particles_f[i].get_flux()
        j_c = self.particles_c[i].get_flux()
        source[i] = (4π·r_f²·n_f·j_f + 4π·r_c²·n_c·j_c) / self.eps_b[i]
    
    # Advection velocity (paper Eq. 24)
    v = self.q / self.eps_b
    
    # Porosity change term (paper Eq. 20, third term)
    eps_change = np.gradient(self.eps_b) / dt
    porosity_term = -eps_change * self.c_b / self.eps_b
    
    # Transport equation
    dc_dz = np.gradient(self.c_b, self.dz)
    self.c_b += dt * (-v * dc_dz + source + porosity_term)
```

**Key Paper Connections:**
- **Eq. 18**: Full transport equation (simplified to Eq. 20)
- **Eq. 21**: Bed porosity `ε_b = 1 - (1-ε_b⁰)·volume_ratio`
- **Eq. 24**: Superficial velocity relationship `v = q/ε_b`

---

## 4. **Multi-Scale Coupling**
**Paper Section 2.3** → **Code: `CoffeeExtraction.step()`**

### Coupling Mechanism:
The paper describes **bi-directional coupling** between scales:

```python
def step(self, target_time: float = None):
    # 1. Update particle boundary conditions (bed → particle)
    for i in range(self.N):
        self.particles_f[i].c_b_boundary = self.c_b[i]  # Paper: c_b varies spatially
        self.particles_c[i].c_b_boundary = self.c_b[i]
    
    # 2. Step particle-level physics
    for i in range(self.N):
        self.particles_f[i].step_swelling(dt)
        self.particles_c[i].step_extraction(dt)
    
    # 3. Update bed porosity from particle swelling
    self._update_porosity()  # Paper Eq. 21
    
    # 4. Step bed-level transport (uses particle fluxes)
    self._step_bed_transport(dt)  # Particles → bed via source term
```

---

## 5. **Flow Control Models**
**Paper Section 2.3** → **Code: `set_flow_conditions()` & `_update_flow_rate()`**

### Fixed Pressure Drop (Paper Eq. 25-28):
```python
def _update_flow_rate(self):
    # Carman-Kozeny permeability (paper Eq. 26)
    k = self.eps_b**3 * d_32**2 / (72 * (1 - self.eps_b)**2)
    
    # Darcy's law (paper Eq. 25)
    self.q = D_avg * self.pressure_drop / self.params.L_z
```

### Fixed Flow Rate:
```python
def set_flow_conditions(self, flow_rate: float):
    self.q = flow_rate  # Constant throughout simulation
    self.fixed_flow = True
```

---

## 6. **Granulometry & Parameters**
**Paper Section 2.5** → **Code: `CoffeeParameters` & number densities**

### Bimodal Particle Distribution (Paper Eq. 19):
```python
# Number densities calculated from paper Eq. 19
self.n_f = (1 - params.eps_b_init) * 3 * params.vol_frac_f / (4 * π * params.r_f_init**3)
self.n_c = (1 - params.eps_b_init) * 3 * params.vol_frac_c / (4 * π * params.r_c_init**3)
```

### Sauter Mean Diameter (Paper Eq. 27):
```python
def _calculate_sauter_mean_diameter(self) -> float:
    d_32 = 2 / (self.params.vol_frac_c/r_c_avg + self.params.vol_frac_f/r_f_avg)
    return d_32
```

---

## 7. **Extraction Metrics**
**Paper Section 2.7** → **Code: `get_extraction_metrics()`** ⚠️ **ISSUE HERE**

### Paper Equations 37-38:
```
Yield = ∫[q(τ)·c_b^N(τ)]dτ / (c₀·∫V_particles dz) × 100%
Strength = ∫[q(τ)·c_b^N(τ)]dτ / (ρ·∫q(τ)dτ) × 100%
```

### Code Implementation (INCORRECT):
```python
# ❌ WRONG: Integrating over space instead of time
total_extracted = np.trapz(self.q * self.c_b, self.z)  
```

### Should be:
```python
# ✅ CORRECT: Integrate over time
total_extracted = ∫(q(t) * c_b_outlet(t)) dt
```

---

## 8. **Numerical Implementation**
**Paper Appendix A.2** → **Code: Finite difference schemes**

### Spatial Discretization:
- **Paper**: Central differences for spatial derivatives
- **Code**: `np.gradient()` for ∂c_b/∂z

### Temporal Integration:
- **Paper**: Crank-Nicolson for particle diffusion, Euler for bed transport
- **Code**: `spsolve()` for implicit particle updates, explicit Euler for bed

### Adaptive Time Stepping:
```python
def _update_time_step(self):
    # Exponential transition (paper approach)
    dt_diff = (self.params.dt_sat - 
               (self.params.dt_sat - self.params.dt_init) * 
               np.exp(-self.t / self.params.tau_swell))
    
    # CFL condition for convection
    dt_cfl = 0.1 * self.dz / v_max
    self.dt = min(dt_diff, dt_cfl)
```

---

## Summary of Implementation Fidelity

| Paper Component | Code Implementation | Fidelity | Issues |
|----------------|-------------------|----------|---------|
| Swelling Model (Eq. 3) | `step_swelling()` | ✅ High | None major |
| Extraction Model (Eq. 9) | `step_extraction()` | ✅ High | Minor boundary condition details |
| Bed Transport (Eq. 20) | `_step_bed_transport()` | ✅ Good | Numerical stability needs improvement |
| Multi-scale Coupling | `step()` | ✅ High | Well implemented |
| Flow Control (Eq. 25-28) | `_update_flow_rate()` | ✅ High | Matches paper |
| Extraction Metrics (Eq. 37-38) | `get_extraction_metrics()` | ❌ **BROKEN** | **Space vs. time integration error** |
| Numerical Methods | Various methods | ✅ Good | Time stepping could be more robust |

The code is a faithful implementation of the paper's methodology, with the **critical exception** being the extraction metrics calculation, which is the root cause of your unrealistic results.